
'use client';

import { useState, useEffect } from 'react';
import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import Image from 'next/image';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Checkbox } from '@/components/ui/checkbox';
import { Badge } from '@/components/ui/badge';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { toast } from 'sonner';
import { ChevronLeft, ChevronRight, Save, Package, CheckCircle2, Upload, X, Trash2 } from 'lucide-react';

interface Category {
  id: string;
  name_en: string;
  name_th: string;
  slug: string;
  parent_id: string | null;
}

interface ProductCategory {
  category_id: string;
  is_primary: boolean;
  category: Category;
}

interface Product {
  id: string;
  sku: string;
  title_en: string;
  title_th: string;
  description_en: string | null;
  supplier: string | null;
  category: string | null;
  images: string[];
  categories: ProductCategory[];
}

export default function CategorizeProductsPage() {
  const { data: session, status } = useSession() || {};
  const router = useRouter();
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [products, setProducts] = useState<Product[]>([]);
  const [categories, setCategories] = useState<Category[]>([]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [selectedCategories, setSelectedCategories] = useState<Set<string>>(new Set());
  const [primaryCategory, setPrimaryCategory] = useState<string | null>(null);
  const [secondaryCategory, setSecondaryCategory] = useState<string | null>(null);
  const [progress, setProgress] = useState({ categorized: 0, total: 0 });
  const [newImageUrl, setNewImageUrl] = useState('');
  const [uploadingImage, setUploadingImage] = useState(false);

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/admin-login');
    }
  }, [status, router]);

  useEffect(() => {
    async function fetchData() {
      try {
        // Fetch categories
        const catRes = await fetch('/api/categories');
        const catData = await catRes.json();
        setCategories(catData);

        // Fetch products with categories included
        const prodRes = await fetch('/api/products?limit=1000&includeCategories=true');
        const prodData = await prodRes.json();
        setProducts(prodData.products || []);
        
        // Calculate progress
        const categorized = prodData.products.filter((p: Product) => 
          p.categories && p.categories.length > 0 && 
          !p.categories.some(c => c.category.name_en === 'Miscellaneous')
        ).length;
        setProgress({ categorized, total: prodData.products.length });
        
        setLoading(false);
      } catch (error) {
        console.error('Error fetching data:', error);
        toast.error('Failed to load data');
        setLoading(false);
      }
    }

    if (status === 'authenticated') {
      fetchData();
    }
  }, [status]);

  useEffect(() => {
    // Load current product's categories
    if (products.length > 0 && currentIndex < products.length) {
      const product = products[currentIndex];
      
      // Safety check: ensure categories array exists
      if (product.categories && Array.isArray(product.categories)) {
        const catIds = new Set(product.categories.map(pc => pc.category_id));
        setSelectedCategories(catIds);
        
        const primary = product.categories.find(pc => pc.is_primary);
        setPrimaryCategory(primary ? primary.category_id : null);
        
        // Set secondary category (first non-primary category)
        const secondary = product.categories.find(pc => !pc.is_primary);
        setSecondaryCategory(secondary ? secondary.category_id : null);
      } else {
        // Product has no categories yet
        setSelectedCategories(new Set());
        setPrimaryCategory(null);
        setSecondaryCategory(null);
      }
      
      // Reset image URL
      setNewImageUrl('');
    }
  }, [currentIndex, products]);

  const handleCategoryToggle = (categoryId: string) => {
    const newSelected = new Set(selectedCategories);
    if (newSelected.has(categoryId)) {
      newSelected.delete(categoryId);
      if (primaryCategory === categoryId) {
        setPrimaryCategory(null);
      }
    } else {
      newSelected.add(categoryId);
      if (!primaryCategory) {
        setPrimaryCategory(categoryId);
      }
    }
    setSelectedCategories(newSelected);
  };

  const handleSetPrimary = (categoryId: string) => {
    if (selectedCategories.has(categoryId)) {
      setPrimaryCategory(categoryId);
    }
  };

  const handleAddImage = async () => {
    if (!newImageUrl.trim()) {
      toast.error('Please enter an image URL');
      return;
    }

    // Validate URL format
    try {
      new URL(newImageUrl.trim());
    } catch (e) {
      toast.error('Please enter a valid URL');
      return;
    }

    setUploadingImage(true);
    const product = products[currentIndex];

    try {
      const response = await fetch(`/api/admin/products/${product.sku}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          images: [newImageUrl.trim(), ...product.images]
        })
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Failed to update image');
      }

      const updatedProduct = await response.json();
      const updatedProducts = [...products];
      updatedProducts[currentIndex] = { ...product, images: updatedProduct.images };
      setProducts(updatedProducts);
      
      toast.success('Image added successfully!');
      setNewImageUrl('');
    } catch (error: any) {
      console.error('Error adding image:', error);
      toast.error(error.message || 'Failed to add image');
    } finally {
      setUploadingImage(false);
    }
  };

  const handleRemoveImage = async (imageIndex: number) => {
    const product = products[currentIndex];
    const newImages = product.images.filter((_, idx) => idx !== imageIndex);

    try {
      const response = await fetch(`/api/admin/products/${product.sku}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          images: newImages
        })
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Failed to remove image');
      }

      const updatedProduct = await response.json();
      const updatedProducts = [...products];
      updatedProducts[currentIndex] = { ...product, images: updatedProduct.images };
      setProducts(updatedProducts);
      
      toast.success('Image removed successfully!');
    } catch (error: any) {
      console.error('Error removing image:', error);
      toast.error(error.message || 'Failed to remove image');
    }
  };

  const handleSave = async () => {
    if (!primaryCategory) {
      toast.error('Please select a primary category');
      return;
    }

    setSaving(true);
    const product = products[currentIndex];

    // Build categories array: primary + secondary (if selected) + other selected checkboxes
    const categoriesToSave = new Set<string>();
    categoriesToSave.add(primaryCategory);
    if (secondaryCategory) {
      categoriesToSave.add(secondaryCategory);
    }
    // Add any additional selected categories
    selectedCategories.forEach(cat => categoriesToSave.add(cat));

    try {
      const response = await fetch(`/api/admin/products/${product.sku}/categories`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          categories: Array.from(categoriesToSave),
          primaryCategory
        })
      });

      if (!response.ok) {
        throw new Error('Failed to save categories');
      }

      toast.success('Categories saved!');
      
      // Update progress
      const updatedProducts = [...products];
      const updatedProduct = await response.json();
      updatedProducts[currentIndex] = updatedProduct;
      setProducts(updatedProducts);
      
      const categorized = updatedProducts.filter(p => 
        p.categories && p.categories.length > 0 && 
        !p.categories.some(c => c.category.name_en === 'Miscellaneous')
      ).length;
      setProgress({ categorized, total: updatedProducts.length });
      
      // Auto-advance to next product
      if (currentIndex < products.length - 1) {
        setTimeout(() => setCurrentIndex(currentIndex + 1), 500);
      }
    } catch (error) {
      console.error('Error saving categories:', error);
      toast.error('Failed to save categories');
    } finally {
      setSaving(false);
    }
  };

  const handlePrevious = () => {
    if (currentIndex > 0) {
      setCurrentIndex(currentIndex - 1);
    }
  };

  const handleNext = () => {
    if (currentIndex < products.length - 1) {
      setCurrentIndex(currentIndex + 1);
    }
  };

  const handleSkip = () => {
    if (currentIndex < products.length - 1) {
      setCurrentIndex(currentIndex + 1);
    }
  };

  const handleDeleteProduct = async () => {
    const product = products[currentIndex];
    
    // Confirm deletion
    if (!window.confirm(`Are you sure you want to delete this product?\n\nSKU: ${product.sku}\n${product.title_en}\n\nThis will mark it as inactive and remove it from the website.`)) {
      return;
    }

    setSaving(true);

    try {
      const response = await fetch(`/api/admin/products/${product.sku}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Failed to delete product');
      }

      // Remove product from the list
      const updatedProducts = products.filter((_, idx) => idx !== currentIndex);
      setProducts(updatedProducts);
      
      // Adjust current index if needed
      if (currentIndex >= updatedProducts.length && currentIndex > 0) {
        setCurrentIndex(currentIndex - 1);
      }
      
      toast.success('Product deleted successfully!');
    } catch (error: any) {
      console.error('Error deleting product:', error);
      toast.error(error.message || 'Failed to delete product');
    } finally {
      setSaving(false);
    }
  };

  if (status === 'loading' || loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <Package className="w-12 h-12 animate-spin mx-auto mb-4 text-accent" />
          <p className="text-muted-foreground">Loading products...</p>
        </div>
      </div>
    );
  }

  if (status === 'unauthenticated') {
    return null;
  }

  if (products.length === 0) {
    return (
      <div className="container mx-auto p-6">
        <Card>
          <CardContent className="p-8 text-center">
            <CheckCircle2 className="w-16 h-16 mx-auto mb-4 text-green-500" />
            <h2 className="text-2xl font-bold mb-2">All Done!</h2>
            <p className="text-muted-foreground">All products have been categorized.</p>
          </CardContent>
        </Card>
      </div>
    );
  }

  const currentProduct = products[currentIndex];
  const progressPercent = Math.round((progress.categorized / progress.total) * 100);

  // Group categories by hierarchy
  const rootCategories = categories.filter(c => !c.parent_id);
  const childCategories = categories.filter(c => c.parent_id);

  return (
    <div className="container mx-auto p-6 max-w-6xl">
      {/* Header */}
      <div className="mb-6">
        <h1 className="text-3xl font-bold mb-2">Product Categorization</h1>
        <div className="flex items-center gap-4">
          <Badge variant="outline" className="text-lg">
            Product {currentIndex + 1} of {products.length}
          </Badge>
          <Badge variant="outline" className="text-lg">
            {progressPercent}% Properly Categorized
          </Badge>
          <div className="flex-1">
            <div className="h-2 bg-muted rounded-full overflow-hidden">
              <div 
                className="h-full bg-accent transition-all duration-300"
                style={{ width: `${progressPercent}%` }}
              />
            </div>
          </div>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Product Info */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Package className="w-5 h-5" />
              Product Information
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            {/* Product Images */}
            <div className="space-y-3">
              <Label className="text-base font-semibold">Product Images</Label>
              
              {/* Current Images */}
              {currentProduct.images && currentProduct.images.length > 0 ? (
                <div className="space-y-2">
                  {currentProduct.images.map((img, idx) => (
                    <div key={idx} className="relative group">
                      <div className="relative aspect-video bg-muted rounded-lg overflow-hidden">
                        <Image
                          src={img}
                          alt={`${currentProduct.title_en} - Image ${idx + 1}`}
                          fill
                          className="object-contain"
                        />
                      </div>
                      <Button
                        size="sm"
                        variant="destructive"
                        className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity"
                        onClick={() => handleRemoveImage(idx)}
                      >
                        <X className="w-4 h-4" />
                      </Button>
                      <p className="text-xs text-muted-foreground mt-1 truncate">{img}</p>
                    </div>
                  ))}
                </div>
              ) : (
                <div className="text-center py-8 border-2 border-dashed rounded-lg">
                  <p className="text-muted-foreground">No images</p>
                </div>
              )}

              {/* Add New Image */}
              <div className="space-y-2">
                <Label htmlFor="new-image-url">Add New Image URL</Label>
                <div className="flex gap-2">
                  <Input
                    id="new-image-url"
                    type="url"
                    placeholder="https://example.com/image.jpg"
                    value={newImageUrl}
                    onChange={(e) => setNewImageUrl(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && handleAddImage()}
                  />
                  <Button
                    onClick={handleAddImage}
                    disabled={uploadingImage || !newImageUrl.trim()}
                    size="sm"
                  >
                    <Upload className="w-4 h-4 mr-2" />
                    {uploadingImage ? 'Adding...' : 'Add'}
                  </Button>
                </div>
              </div>
            </div>

            {/* Product Details */}
            <div className="space-y-2 pt-4 border-t">
              <div>
                <p className="text-sm text-muted-foreground">SKU</p>
                <p className="font-mono font-semibold">{currentProduct.sku}</p>
              </div>

              <div>
                <p className="text-sm text-muted-foreground">English Title</p>
                <p className="font-semibold">{currentProduct.title_en}</p>
              </div>

              {currentProduct.title_th && (
                <div>
                  <p className="text-sm text-muted-foreground">Thai Title</p>
                  <p className="font-semibold">{currentProduct.title_th}</p>
                </div>
              )}

              {currentProduct.supplier && (
                <div>
                  <p className="text-sm text-muted-foreground">Supplier</p>
                  <Badge variant="secondary">{currentProduct.supplier}</Badge>
                </div>
              )}

              {currentProduct.description_en && (
                <div>
                  <p className="text-sm text-muted-foreground">Description</p>
                  <p className="text-sm line-clamp-3">{currentProduct.description_en}</p>
                </div>
              )}
            </div>
          </CardContent>
        </Card>

        {/* Category Selection */}
        <Card>
          <CardHeader>
            <CardTitle>Assign Categories</CardTitle>
            <p className="text-sm text-muted-foreground">
              Select the primary and optional secondary category from dropdowns, then add more if needed.
            </p>
          </CardHeader>
          <CardContent className="space-y-6">
            {/* Primary Category Dropdown */}
            <div className="space-y-2">
              <Label htmlFor="primary-category" className="text-base font-semibold">
                Primary Category <span className="text-red-500">*</span>
              </Label>
              <Select
                value={primaryCategory || undefined}
                onValueChange={(value) => {
                  setPrimaryCategory(value);
                  // Ensure primary category is in selected categories
                  const newSelected = new Set(selectedCategories);
                  newSelected.add(value);
                  setSelectedCategories(newSelected);
                }}
              >
                <SelectTrigger id="primary-category" className="w-full">
                  <SelectValue placeholder="Select primary category..." />
                </SelectTrigger>
                <SelectContent>
                  {rootCategories.map(rootCat => {
                    const children = childCategories.filter(c => c.parent_id === rootCat.id);
                    
                    return (
                      <div key={rootCat.id}>
                        {/* Root category option */}
                        <SelectItem value={rootCat.id}>
                          üìÅ {rootCat.name_en}
                        </SelectItem>
                        
                        {/* Child category options */}
                        {children.map(childCat => (
                          <SelectItem 
                            key={childCat.id} 
                            value={childCat.id}
                            className="pl-8"
                          >
                            üìÑ {childCat.name_en}
                          </SelectItem>
                        ))}
                      </div>
                    );
                  })}
                </SelectContent>
              </Select>
              {primaryCategory && (
                <p className="text-sm text-muted-foreground mt-1">
                  ‚úì Primary: <strong>{categories.find(c => c.id === primaryCategory)?.name_en}</strong>
                </p>
              )}
            </div>

            {/* Secondary Category Dropdown */}
            <div className="space-y-2">
              <Label htmlFor="secondary-category" className="text-base font-semibold">
                2nd Category <span className="text-muted-foreground text-sm font-normal">(Optional)</span>
              </Label>
              <Select
                value={secondaryCategory || undefined}
                onValueChange={(value) => {
                  if (value === primaryCategory) {
                    toast.error('Secondary category cannot be the same as primary');
                    return;
                  }
                  setSecondaryCategory(value || null);
                  if (value) {
                    const newSelected = new Set(selectedCategories);
                    newSelected.add(value);
                    setSelectedCategories(newSelected);
                  }
                }}
              >
                <SelectTrigger id="secondary-category" className="w-full">
                  <SelectValue placeholder="Select 2nd category (optional)..." />
                </SelectTrigger>
                <SelectContent>
                  {rootCategories.map(rootCat => {
                    const children = childCategories.filter(c => c.parent_id === rootCat.id);
                    
                    return (
                      <div key={rootCat.id}>
                        {/* Root category option */}
                        {rootCat.id !== primaryCategory && (
                          <SelectItem value={rootCat.id}>
                            üìÅ {rootCat.name_en}
                          </SelectItem>
                        )}
                        
                        {/* Child category options */}
                        {children.map(childCat => 
                          childCat.id !== primaryCategory && (
                            <SelectItem 
                              key={childCat.id} 
                              value={childCat.id}
                              className="pl-8"
                            >
                              üìÑ {childCat.name_en}
                            </SelectItem>
                          )
                        )}
                      </div>
                    );
                  })}
                </SelectContent>
              </Select>
              {secondaryCategory && (
                <p className="text-sm text-muted-foreground mt-1">
                  ‚úì 2nd: <strong>{categories.find(c => c.id === secondaryCategory)?.name_en}</strong>
                </p>
              )}
            </div>

            {/* Additional Categories (Optional) */}
            <div className="space-y-2">
              <Label className="text-base font-semibold">
                Additional Categories <span className="text-muted-foreground text-sm font-normal">(Optional)</span>
              </Label>
              <p className="text-sm text-muted-foreground mb-3">
                Check any other categories if needed (beyond primary and 2nd).
              </p>
              
              <div className="space-y-3 max-h-[400px] overflow-y-auto pr-2 border rounded-lg p-3">
                {rootCategories.map(rootCat => {
                  const children = childCategories.filter(c => c.parent_id === rootCat.id);
                  const isRootSelected = selectedCategories.has(rootCat.id);
                  const isRootPrimary = primaryCategory === rootCat.id;
                  const isRootSecondary = secondaryCategory === rootCat.id;

                  return (
                    <div key={rootCat.id} className="space-y-2">
                      {/* Root Category */}
                      <div className="flex items-center gap-3 p-2 rounded hover:bg-muted">
                        <Checkbox
                          id={`add-cat-${rootCat.id}`}
                          checked={isRootSelected}
                          disabled={isRootPrimary || isRootSecondary}
                          onCheckedChange={() => {
                            if (!isRootPrimary && !isRootSecondary) {
                              handleCategoryToggle(rootCat.id);
                            }
                          }}
                        />
                        <label
                          htmlFor={`add-cat-${rootCat.id}`}
                          className={`flex-1 font-medium cursor-pointer ${(isRootPrimary || isRootSecondary) ? 'opacity-50' : ''}`}
                        >
                          üìÅ {rootCat.name_en}
                          {isRootPrimary && <Badge variant="default" className="ml-2 bg-accent">Primary</Badge>}
                          {isRootSecondary && <Badge variant="secondary" className="ml-2">2nd</Badge>}
                        </label>
                      </div>

                      {/* Child Categories */}
                      {children.length > 0 && (
                        <div className="ml-6 space-y-1">
                          {children.map(childCat => {
                            const isChildSelected = selectedCategories.has(childCat.id);
                            const isChildPrimary = primaryCategory === childCat.id;
                            const isChildSecondary = secondaryCategory === childCat.id;

                            return (
                              <div key={childCat.id} className="flex items-center gap-3 p-2 rounded hover:bg-muted">
                                <Checkbox
                                  id={`add-cat-${childCat.id}`}
                                  checked={isChildSelected}
                                  disabled={isChildPrimary || isChildSecondary}
                                  onCheckedChange={() => {
                                    if (!isChildPrimary && !isChildSecondary) {
                                      handleCategoryToggle(childCat.id);
                                    }
                                  }}
                                />
                                <label
                                  htmlFor={`add-cat-${childCat.id}`}
                                  className={`flex-1 text-sm cursor-pointer ${(isChildPrimary || isChildSecondary) ? 'opacity-50' : ''}`}
                                >
                                  üìÑ {childCat.name_en}
                                  {isChildPrimary && <Badge variant="default" className="ml-2 bg-accent text-xs">Primary</Badge>}
                                  {isChildSecondary && <Badge variant="secondary" className="ml-2 text-xs">2nd</Badge>}
                                </label>
                              </div>
                            );
                          })}
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>

            {/* Summary */}
            {(primaryCategory || selectedCategories.size > 0) && (
              <div className="p-3 bg-muted rounded-lg">
                <p className="text-sm font-semibold mb-2">Summary:</p>
                <div className="flex flex-wrap gap-2">
                  {primaryCategory && (
                    <Badge 
                      variant="default"
                      className="bg-accent"
                    >
                      ‚òÖ {categories.find(c => c.id === primaryCategory)?.name_en}
                    </Badge>
                  )}
                  {secondaryCategory && (
                    <Badge variant="secondary">
                      2nd: {categories.find(c => c.id === secondaryCategory)?.name_en}
                    </Badge>
                  )}
                  {Array.from(selectedCategories)
                    .filter(catId => catId !== primaryCategory && catId !== secondaryCategory)
                    .map(catId => {
                      const cat = categories.find(c => c.id === catId);
                      return cat ? (
                        <Badge 
                          key={catId} 
                          variant="outline"
                        >
                          {cat.name_en}
                        </Badge>
                      ) : null;
                    })}
                </div>
              </div>
            )}
          </CardContent>
        </Card>
      </div>

      {/* Navigation */}
      <div className="mt-6 flex items-center justify-between gap-4">
        <Button
          variant="outline"
          onClick={handlePrevious}
          disabled={currentIndex === 0}
        >
          <ChevronLeft className="w-4 h-4 mr-2" />
          Previous
        </Button>

        <div className="flex gap-2">
          <Button
            variant="destructive"
            onClick={handleDeleteProduct}
            disabled={saving}
            className="gap-2"
          >
            <Trash2 className="w-4 h-4" />
            Delete Product
          </Button>
          <Button
            variant="outline"
            onClick={handleSkip}
            disabled={currentIndex === products.length - 1}
          >
            Skip
          </Button>
          <Button
            onClick={handleSave}
            disabled={saving || !primaryCategory}
            className="bg-accent hover:bg-accent/90"
          >
            <Save className="w-4 h-4 mr-2" />
            {saving ? 'Saving...' : 'Save & Next'}
          </Button>
        </div>

        <Button
          variant="outline"
          onClick={handleNext}
          disabled={currentIndex === products.length - 1}
        >
          Next
          <ChevronRight className="w-4 h-4 ml-2" />
        </Button>
      </div>
    </div>
  );
}
